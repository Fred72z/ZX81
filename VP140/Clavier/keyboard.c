// Interface clavier minitel vers ZX81

//#include <p16F876.inc>

#pragma config=0x3f3a

#pragma bit RESET @ PORTA.4
#pragma bit KB_LATCH @ PORTC.0
#pragma bit KB_DATA @ PORTC.1
#pragma bit KB_CLK @ PORTC.2
#pragma bit VOL_A @ PORTC.5
#pragma bit VOL_B @ PORTC.4


// A8,A9,A10,A11,A12,A13,A14,A15 -- KBD4-KBD0
const uns8 decod0[64]={
// Espace
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
// Ctrl
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
// Sommaire
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// N
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
// '
0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
// H
0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,
// Y
0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,
// Fleche bas
0x01,0x00,0x00,0x00,0x10,0x00,0x00,0x00
};

const uns8 decod1[64]={
// W
0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
// Q
0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
// A
0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
// V
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// ,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
// F
0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
// R
0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,
// Annul
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

const uns8 decod2[64]={
// X
0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// S
0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
// Z
0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// C
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// Esc
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
// D
0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
// E
0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
// Corr
0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00
};

const uns8 decod3[64]={
// Conn/Fin
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// Fct
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// Guide
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// B
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
// .
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
// G
0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
// T
0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
// Fleche haut
0x01,0x00,0x00,0x00,0x08,0x00,0x00,0x00
};

const uns8 decod4[64]={
// 3
0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,
// M
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,
// P
0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
// 2
0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
// Rep
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 1
0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
// ?
0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// Return
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00
};

const uns8 decod5[64]={
// 6
0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,
// L
0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
// O
0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,
// 5
0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
// Envoi
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
// 4
0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,
// :
0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// fleche droite
0x01,0x00,0x00,0x00,0x04,0x00,0x00,0x00
};

const uns8 decod6[64]={
// 9
0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
// K
0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,
// I
0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,
// 8
0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
// Retour
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// 7
0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,
// -
0x01,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
// fleche gauche
0x01,0x00,0x00,0x10,0x00,0x00,0x00,0x00
};

const uns8 decod7[64]={
// #
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// J
0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
// U
0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,
// 0
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
// Suite
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// *
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x10,
// ;
0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
// Shift
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

const uns8 rep[56]={
// RAND
0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
// (F)
0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,
// USR
0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,
// 8
0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
// 8
0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
// 0
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
// 0
0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00
};


uns8 MAT[8];
uns8 MAT1[8];
uns8 KB[8];
uns8 VOLUME;


void scan();
uns8 test_RESET();
uns8 test_VOLUME();
void tempo_1ms();
void tempo_10ms();
void tempo_50ms();
void tempo_100ms();
void conversion();
void trf();
void raz_KB();
void copy_MAT();
uns8 compare_MAT();
uns8 noKey();
void waitnoKey();
uns8 test_REP();
void send_REP();


void main()
{
	uns8 i,bcle;
	TRISA=0x00;
	TRISB=0xFF;
	TRISC=0x00;
	ADCON1=0;
	OPTION=0x02;		// pullups activés sur le portB
	
	PORTC=0;
	PORTA=0x10;

	VOLUME=1;
	
	for (i=0;i<8;i++)
			{
				MAT[i]=0;
				KB[i]=0;
			}
	bcle=0;
	copy_MAT();

while (1)
{

 if (bcle==0) copy_MAT();
 scan();

 if ((compare_MAT()==1) && (bcle<4)) bcle++;
 if (compare_MAT()==0) bcle=0;


 if (test_RESET()==1)
			{
			 	RESET=0;
				tempo_100ms();
			 	RESET=1;
				waitnoKey();
			}
 if ((test_VOLUME()==1) && (VOLUME<3))
			{
				 VOLUME++;
				 waitnoKey();
			}
 if ((test_VOLUME()==2) && (VOLUME>0))
			{
				 VOLUME--;
				 waitnoKey();
			}

 if (test_REP()==1)
			 	 send_REP();


 conversion();

 if (bcle>3) raz_KB();
 trf();
 VOL_A=VOLUME.0;
 VOL_B=VOLUME.1;
 tempo_10ms();
 if (bcle>3) 
				{
					tempo_100ms();
					bcle=0;
				}
 }
}


void send_REP()
{
   uns8 a,n,i,j;
	n=0;
	for (i=0;i<7;i++)
		{
			raz_KB();
			trf();
			tempo_50ms();
			for (j=0;j<8;j++)
					{
						a=rep[n];
						KB[j]=a;
						n++;
					}
			trf();
			tempo_50ms();
		}
			raz_KB();
			trf();
			tempo_50ms();
}

void copy_MAT()
{
 uns8 i,a;
 for (i=0;i<8;i++)
		{
			a=MAT[i];
			MAT1[i]=a;
		}
}

uns8 compare_MAT()
{
 uns8 i,a,b,cp;
 cp=1;
 b=1;
 for (i=0;i<8;i++)
	{
		a=MAT1[i];
		if (a!=MAT[i]) cp=0;
		if (a!=0) b=0;

	}
 if (b==1) cp=0;		// si MAT=0 alors differente
 return cp;
}




// scanne la matrice du clavier et retourne les 8 valeurs dans le tableau MAT
void scan()
{
	uns8 n;

	for (n=0;n<8;n++)
		{
			PORTA=0x10 | n;
			nop();
			MAT[n]=255-PORTB;
		}
}

uns8 noKey()
{
	uns8 i,r;
	r=1;
	for (i=0;i<8;i++)
			if (MAT[i]!=0) r=0;

	return r;
}

void waitnoKey()
{
	while (noKey()!=1)
		{
				scan();
				tempo_10ms();
		}
}


uns8 test_RESET()	// teste si les touches Fnct+Fin sont appuyées
{
	uns8 i,r;
	r=1;
	for (i=0;i<8;i++)
	switch(i)
		{
			case 3  : if (MAT[i]!=0xC0) r=0; break;
			default : if (MAT[i]!=0x00) r=0;
		}
	return r;
}


uns8 test_VOLUME()	// teste si les touches Sommaire ou Guide sont appuyées
{
	uns8 i,r,s;
	r=1;
	s=0;
	for (i=0;i<8;i++)
	switch(i)
		{
			case 0  : if (MAT[i]!=0x20) r=0; break;
			default : if (MAT[i]!=0x00) r=0;
		}

	if (r==1) s=2; // Sommaire appuyée
	else
	{
	r=1;
	for (i=0;i<8;i++)
	switch(i)
		{
			case 3  : if (MAT[i]!=0x20) r=0; break;
			default : if (MAT[i]!=0x00) r=0;
		}
	if (r==1) s=1; // Guide appuyée
	}

	return s;
}




uns8 test_REP()	// teste si la touche Repetition est appuyée
{
	uns8 i,r;
	r=1;
	for (i=0;i<8;i++)
	switch(i)
		{
			case 4  : if (MAT[i]!=0x08) r=0; break;
			default : if (MAT[i]!=0x00) r=0;
		}
	return r;
}


void tempo_1ms()
{
	TMR0=0;
	T0IF=0;
	while (T0IF!=1);
}

void tempo_10ms()
{
 	uns8 i;
	for (i=0; i<10;i++)
				tempo_1ms();
}

void tempo_50ms()
{
 	uns8 i;
	for (i=0; i<50;i++)
				tempo_1ms();
}

void tempo_100ms()
{
	uns8 i;
	for (i=0; i<100;i++)
				tempo_1ms();
}



void raz_KB()
{
	uns8 i;
	for (i=0;i<8;i++) KB[i]=0;	// vide le tableau
}


//traduit les touches Minitel vers ZX
// KB[x] contient les touches actives

void conversion()
{
	uns8 k,b;
	uns8 i,j,a,n;
	uns16 ad;
	
	raz_KB();
	

	for (i=0;i<8;i++)
	{	
	ad=0;
	k=MAT[i];
	for (b=0;b<8;b++)
			{
				if (k.7!=0) 
					for (j=0;j<8;j++)
						{
							n=ad+j;
							a=0;
							switch (i)
								{
									case 0 : a=decod0[n]; break;	
									case 1 : a=decod1[n]; break;	
									case 2 : a=decod2[n]; break;	
									case 3 : a=decod3[n]; break;	
									case 4 : a=decod4[n]; break;	
									case 5 : a=decod5[n]; break;	
									case 6 : a=decod6[n]; break;	
									case 7 : a=decod7[n]; break;	
								}

							KB[j]=KB[j] | a;
						}
				k=k*2;
				ad=ad+8;
			}
	}

}



// envoi les données du tableau KB vers les registres du CPLD
void trf()
{
	uns8 n,d,b;
	for (n=8;n>0;n--)
		{
			d=KB[n-1];
		//	d=MAT[n];
			for (b=0;b<5;b++)
				{
					KB_DATA=d.4;
					KB_CLK=1;
					d=d*2;
					KB_CLK=0;
				}
			nop();
			nop();	
		}
	KB_LATCH=1;
	nop();
	nop();
	KB_LATCH=0;
}